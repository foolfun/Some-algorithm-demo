# Some-algorithm-demo
经典算法的简单demo，python版本 <br>
目前包括：
## Fibonacci.py n的因子之和,斐波那契数列
(1)给定正整数 n，确定 n 是否是它的所有因子之和。比如 n=6 时，它的所有因子分别为 1,2,3，由于6=1+2+3，所以 6 满足条件. <br>
要求：`输入`：正整数 n ；`输出`：若 n 是它的所有因子之和，输出 YES ，否则，输出 NO。请给出至少两种方法，并分析对比它们的时间复杂度
(2)编写程序计算斐波那契数列之和：1,2,2,3,5,8,13,21,34<br>
要求：使用`递归方法`实现以上算法；对比递归算法的实现过程，从时间复杂度和空间复杂度上考虑
是否可以改进递归算法
## quickSort_mergeSort.py 合并排序&快速排序
给定 n 个元素，这些元素是`无序的`，分别使用`合并排序`和`快速排序`对 n 个元素进行排序。<br>
要求:写出两种排序算法的完整程序， 测试两种算法的时间复杂度，对比它们的优劣
## BiSearch.py 二分查找
给定 n 个元素，这些元素是`有序的`（假定为升序），使用`二分查找`特定的元素。<br>
要求:`输入 `n 个元素，输入某一个特定的值 m ，首先对 n 个元素进行排序（排序算法任选），`输出 `m 值的位置序号
## Matrix_multiplication.py 矩阵连乘，动态规划
给定 n 个矩阵{A 0 ,A 1 ,A 2 , …, A n-1 }，其中 Ai，i=0, …, n-1 的维数为p i *p i+1 ，并且A i 和A i+1 是可乘的。考察这n个矩阵的连乘积A 0 A 1 A 2 …A n-1 ，由于矩阵乘法满足结合律，所以计算矩阵的连乘可以有多种不同的计算次序。结合动态规划思想，编程确定 n 个矩阵的连乘次序，使得按照这个次数计算矩阵连乘，需要的“数乘”次数最少。<br>
要求:`输入 `矩阵个数 n ，以及每一个矩阵的尺寸；`输出 `最佳矩阵连乘次序和数乘次数。
